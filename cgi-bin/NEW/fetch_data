#!/bin/sh

# Set content-type for JSON response
echo "Content-type: application/json"
echo ""

# Define file paths and lock keyword
QUEUE_FILE="/tmp/at_pipe.txt"
LOCK_KEYWORD="FETCH_DATA_LOCK"

# Function to output error in JSON format
output_error() {
    printf '{"error": "%s"}\n' "$1"
    exit 1
}

# Improved JSON string escaping function
escape_json() {
    # Use printf to handle escaping more reliably
    printf '%s' "$1" | awk '
    BEGIN { RS="\n"; ORS="\\n" }
    {
        gsub(/\\/, "\\\\")
        gsub(/"/, "\\\"")
        gsub(/\r/, "")
        gsub(/\t/, "\\t")
        gsub(/\f/, "\\f")
        gsub(/\b/, "\\b")
        print
    }
    ' | sed 's/\\n$//'
}

# Function to add lock entry
add_lock() {
    printf '{"id":"%s","timestamp":"%s","command":"%s","status":"lock"}\n' \
        "${LOCK_KEYWORD}" \
        "$(date '+%H:%M:%S')" \
        "${LOCK_KEYWORD}" >> "${QUEUE_FILE}"
    sleep 0.1
}

# Function to remove lock entry
remove_lock() {
    sed -i "/${LOCK_KEYWORD}/d" "${QUEUE_FILE}"
}

# Function to process AT commands
process_commands() {
    local commands="$1"
    local first=1
    
    # Start JSON array
    printf '['
    
    # Add lock entry to pause queue processor
    add_lock
    
    # Process each command
    for cmd in $commands; do
        # Add comma separator if not first item
        [ $first -eq 0 ] && printf ','
        first=0
        
        # Run the command using sms_tool
        OUTPUT=$(sms_tool at "$cmd" 2>/dev/null) || OUTPUT="Error executing command"
        
        # Properly escape both command and output for JSON
        ESCAPED_CMD=$(escape_json "$cmd")
        ESCAPED_OUTPUT=$(escape_json "$OUTPUT")
        
        # Format JSON object with proper escaping
        printf '{"command":"%s","response":"%s"}' \
            "${ESCAPED_CMD}" \
            "${ESCAPED_OUTPUT}"
        
        sleep 0.1
    done
    
    # Close JSON array
    printf ']\n'
    
    # Remove lock entry
    remove_lock
}

# Define command sets
define_command_sets() {
    COMMAND_SET_1='AT+QUIMSLOT? AT+CNUM AT+COPS? AT+CIMI AT+ICCID AT+CGSN AT+CPIN? AT+CGDCONT? AT+CREG? AT+CFUN? AT+QENG="servingcell" AT+QTEMP AT+CGCONTRDP AT+QCAINFO AT+QRSRP AT+QMAP="WWAN" AT+C5GREG=2;+C5GREG? AT+CGREG=2;+CGREG? AT+QRSRQ AT+QSINR'
    COMMAND_SET_2='AT+CGDCONT? AT+CGCONTRDP AT+QNWPREFCFG="mode_pref" AT+QNWPREFCFG="nr5g_disable_mode" AT+QUIMSLOT?'
    COMMAND_SET_3='AT+CGMI AT+CGMM AT+QGMR AT+CNUM AT+CIMI AT+ICCID AT+CGSN AT+QMAP="LANIP" AT+QMAP="WWAN" AT+QGETCAPABILITY'
    COMMAND_SET_4='AT+QMAP="MPDN_RULE" AT+QMAP="DHCPV4DNS" AT+QCFG="usbnet"'
    COMMAND_SET_5='AT+QRSRP AT+QRSRQ AT+QSINR AT+QCAINFO AT+QSPN'
    COMMAND_SET_6='AT+CEREG=2;+CEREG? AT+C5GREG=2;+C5GREG? AT+CPIN? AT+CGDCONT? AT+CGCONTRDP AT+QMAP="WWAN" AT+QRSRP AT+QTEMP AT+QNETRC?'
    COMMAND_SET_7='AT+QNWPREFCFG="policy_band" AT+QNWPREFCFG="lte_band";+QNWPREFCFG="nsa_nr5g_band";+QNWPREFCFG="nr5g_band"'
    COMMAND_SET_8='AT+QNWLOCK="common/4g" AT+QNWLOCK="common/5g" AT+QNWLOCK="save_ctrl"'
}

# Main execution
define_command_sets

# Get command set from query string
COMMAND_SET=$(echo "$QUERY_STRING" | grep -o 'set=[1-8]' | cut -d'=' -f2 | tr -cd '0-9')

# Select the appropriate command set
case "$COMMAND_SET" in
    1) COMMANDS="$COMMAND_SET_1";;
    2) COMMANDS="$COMMAND_SET_2";;
    3) COMMANDS="$COMMAND_SET_3";;
    4) COMMANDS="$COMMAND_SET_4";;
    5) COMMANDS="$COMMAND_SET_5";;
    6) COMMANDS="$COMMAND_SET_6";;
    7) COMMANDS="$COMMAND_SET_7";;
    8) COMMANDS="$COMMAND_SET_8";;
    *) COMMANDS="$COMMAND_SET_1";; # Default to set 1 if no valid set specified
esac

# Ensure lock is removed even if script fails
trap remove_lock EXIT

# Process the selected commands and output directly
process_commands "$COMMANDS"